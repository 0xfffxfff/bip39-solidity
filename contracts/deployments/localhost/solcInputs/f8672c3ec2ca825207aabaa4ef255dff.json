{
  "language": "Solidity",
  "sources": {
    "src/BIP39.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\ncontract BIP39 {\n    string constant public language = \"english\";\n    string[2048] public wordlist;\n    bool public finalized;\n    address private deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    modifier onlyDeployer {\n        require(msg.sender == deployer, \"only deployer\");\n        _;\n    }\n\n    function commitWords(string[] memory _wordsChunk, uint256 _offset) external onlyDeployer {\n        require(!finalized, \"finalized\");\n        require(_offset + _wordsChunk.length - 1 < 2048, \"index too high\");\n        for (uint256 i = 0; i < _wordsChunk.length; i++) {\n            wordlist[_offset + i] = _wordsChunk[i];\n        }\n    }\n\n    function finalizeWords() external onlyDeployer {\n        finalized = true;\n    }\n\n    function getWordlist() external view returns (string[2048] memory) {\n        return wordlist;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                BIP39\n    //////////////////////////////////////////////////////////////*/\n\n    function entropyToMnemonic(bytes memory entropy) public pure returns (uint[] memory) {\n        bytes32 hashedEntropy = sha256(entropy);\n        string memory binaryEntropy = \"\";\n        for (uint i = 0; i < entropy.length; i++) {\n            binaryEntropy = string(abi.encodePacked(binaryEntropy, uintToBinaryString(uint8(entropy[i]), 8)));\n        }\n        string memory binaryChecksum = substring(uintToBinaryString(uint256(hashedEntropy), 256), 0, entropy.length * 8 / 4);\n        string memory binaryString = string(abi.encodePacked(binaryEntropy, binaryChecksum));\n\n        uint mnemonicLength = (entropy.length * 8 + entropy.length / 4 + 7) / 11;\n\n        uint[] memory mnemonicIndices = new uint[](mnemonicLength);\n        for (uint i = 0; i < mnemonicLength; i++) {\n            uint index = binaryToUint(substring(binaryString, i * 11, min((i+1) * 11, bytes(binaryString).length)));\n            mnemonicIndices[i] = index;\n        }\n        return mnemonicIndices;\n    }\n\n\n    function entropyToMnemonicString(bytes memory entropy) public view returns (string[] memory) {\n        return indicesToWords(entropyToMnemonic(entropy));\n    }\n\n    function mnemonicToEntropy(uint[] memory wordIndices) public pure returns (bytes memory) {\n        require(wordIndices.length >= 3 && wordIndices.length <= 24 && wordIndices.length % 3 == 0, \"Invalid word count\");\n\n        uint concatLenBits = wordIndices.length * 11;\n        bytes memory concatBits = new bytes(concatLenBits);\n\n        for (uint wordIndex = 0; wordIndex < wordIndices.length; wordIndex++) {\n            uint ndx = wordIndices[wordIndex];\n\n            for (uint i = 0; i < 11; i++) {\n                bool isOne = (ndx & (1 << (10 - i))) != 0;\n                concatBits[(wordIndex * 11) + i] = isOne ? bytes1(uint8(1)) : bytes1(uint8(0));\n            }\n        }\n\n        uint checksumLengthBits = concatLenBits / 33;\n        uint entropyLengthBits = concatLenBits - checksumLengthBits;\n\n        bytes memory entropy = new bytes(entropyLengthBits / 8);\n        for (uint i = 0; i < entropy.length; i++) {\n            for (uint j = 0; j < 8; j++) {\n                if (uint8(concatBits[(i * 8) + j]) == 1) {\n                    entropy[i] = bytes1(uint8(entropy[i]) | uint8(1 << (7 - j)));\n                }\n            }\n        }\n\n        bytes32 hashBytes = sha256(entropy);\n\n        for (uint i = 0; i < checksumLengthBits; i++) {\n            require(\n                uint8(concatBits[entropyLengthBits + i]) == uint8(uint8(hashBytes[i / 8]) >> (7 - i % 8) & 1),\n                \"Failed checksum\"\n            );\n        }\n\n        return entropy;\n    }\n\n    function generateMnemonic(uint256 words) public view returns (uint[] memory) {\n        require(words >= 3 && words <= 24 && words % 3 == 0, \"Invalid word count\");\n        bytes memory entropy = generateEntropy(words);\n        uint[] memory mnemonicIndices = entropyToMnemonic(entropy);\n        return mnemonicIndices;\n    }\n\n    function generateMnemonicString(uint256 words) public view returns (string[] memory) {\n        return indicesToWords(generateMnemonic(words));\n    }\n\n    function indicesToWords(uint256[] memory indices) public view returns (string[] memory) {\n        string[] memory words = new string[](indices.length);\n        for (uint index; index < indices.length; index++) {\n            words[index] = wordlist[indices[index]];\n        }\n        return words;\n    }\n\n    function generateEntropy(uint256 words) public view returns (bytes memory) {\n        require(words >= 3 && words <= 24 && words % 3 == 0, \"Invalid word count\");\n\n        bytes32 totalEntropy = keccak256(abi.encodePacked(\n            tx.origin,\n            blockhash(block.number - 1),\n            block.timestamp,\n            gasleft()\n        ));\n\n        uint256 bits = words / 3 * 32;\n        uint256 bytesLength = bits / 8;\n\n        bytes memory entropy = new bytes(bytesLength);\n        for (uint i = 0; i < bytesLength; i++) {\n            entropy[i] = totalEntropy[i];\n        }\n        return entropy;\n    }\n\n\n    /*//////////////////////////////////////////////////////////////\n                                Utility\n    //////////////////////////////////////////////////////////////*/\n\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex - startIndex);\n        for (uint i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function uintToBinaryString(uint256 x, uint256 length) internal pure returns (string memory) {\n        bytes memory result = new bytes(length);\n        for (uint i = 0; i < length; i++) {\n            uint8 b = uint8(uint(x) >> (length - 1 - i));\n            result[i] = b % 2 == 0 ? bytes1(uint8(48)) : bytes1(uint8(49));  // 48 and 49 are '0' and '1' in ASCII\n        }\n        return string(result);\n    }\n\n    function binaryToUint(string memory binaryString) internal pure returns (uint) {\n        bytes memory binaryBytes = bytes(binaryString);\n        uint result = 0;\n        for (uint i = 0; i < binaryBytes.length; i++) {\n            if (binaryBytes[i] == '1') {\n                result += 2**(binaryBytes.length - i - 1);\n            }\n        }\n        return result;\n    }\n\n    function min(uint a, uint b) private pure returns (uint) {\n        return a < b ? a : b;\n    }\n}"
    },
    "src/SeedPoems.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"solmate/src/tokens/ERC721.sol\";\nimport \"solmate/src/auth/Owned.sol\";\nimport \"solady/src/utils/SSTORE2.sol\";\nimport \"./BIP39.sol\";\nimport {Render} from \"./libraries/Render.sol\";\n\n////////////////////////////////////////////////////////////////////////\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                               seek                                 //\n//                               poet                                 //\n//                               seed                                 //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                       0xfff.eth    //\n//                                                                    //\n////////////////////////////////////////////////////////////////////////\n\ncontract SeedPoems is ERC721, BIP39, Owned {\n    struct Seed {\n        uint256[] indices;\n        bytes entropy;\n        bool bound;\n    }\n    mapping(uint256 => Seed) public seeds;\n\n    uint256 public totalSupply; // => 2048 words ~ 70~650 / 200-250 realistic\n    uint256 public wordPrice = 0.01 ether; // 2048 words => 20.48 ETH\n\n    // Scenario A\n    // First 512 free\n    // Then 0.01\n\n    // Scenario B\n    // First 512 free\n    // Next 512 0.005\n    // Next 512 0.01\n    // Last 512 0.015\n\n    // Scenario C\n    // Potential curve\n    // first 512 free\n    // next 512 0.005\n    // next 512 0.01\n    // next 256 0.02\n    // next 128 0.03\n    // next 64 0.04\n    // next 32 0.05\n    // next 16 0.1\n    // next 8 0.2\n    // next 6 0.5\n    // next 2 1\n\n    bool public locked = true; // prevent minting\n\n    // mapping(uint256 => bool) public isIndexMinted;\n    mapping(bytes32 => bool) public isEntropyMinted;\n    uint256 totalWords = 0; // total minted words\n\n    address private font;\n\n    constructor() ERC721(\"Seed Poem\", \"SEED\") Owned(msg.sender) {\n        uint256[] memory seedIndices = new uint256[](3);\n        seedIndices[0] = 1560; // seek\n        seedIndices[1] = 1337; // poet\n        seedIndices[2] = 1559; // seed\n        _mintPoem(seedIndices, false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                  Mint\n    //////////////////////////////////////////////////////////////*/\n\n    function lock(bool state) external onlyOwner {\n        locked = state;\n    }\n\n    function mint(uint256[] memory seedIndices) external payable {\n        uint seedPrice = wordPrice * seedIndices.length;\n        require(!locked, \"LOCKED\");\n        require(msg.value == seedPrice, \"PRICE\");\n        _mintPoem(seedIndices, false);\n    }\n\n    // function mintAndBind(uint256[] memory seedIndices, address to) external payable {\n    //     // TODO: Verify signature\n    //     _mintPoem(seedIndices, true);\n    // }\n\n    function _mintPoem(uint256[] memory seedIndices, bool bound) internal {\n        uint id = ++totalSupply;\n\n        // Keep track of words minted\n        totalWords += seedIndices.length;\n        require(totalWords < 2048, \"MINTABLE_WORD_LIMIT_REACHED_2048\");\n\n        // This generates the entropy from the seed indices\n        // and simultaneously validates the seed.\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n\n        // Words can only be minted once\n        // for (uint i = 0; i < seedIndices.length; i++) {\n        //     require(!isIndexMinted[seedIndices[i]], \"WORD_ALREADY_MINTED\");\n        //     isIndexMinted[seedIndices[i]] = true;\n        // }\n        // hash entropy to check if it has been minted\n        bytes32 entropyHash = keccak256(entropy);\n        require(!isEntropyMinted[entropyHash], \"MNEMONIC_ALREADY_MINTED\");\n        isEntropyMinted[entropyHash] = true;\n\n        // Store the seed\n        seeds[id] = Seed({\n            indices: seedIndices,\n            entropy: entropy,\n            bound: bound\n        });\n\n        // Mint the token\n        _mint(msg.sender, id);\n    }\n\n    /**\n     * @dev Intended to be used offchain\n     */\n    function getMintedIndices() external view returns (uint256[] memory) {\n        uint256[] memory mintedIndicesArray = new uint256[](totalWords);\n        uint words = 0;\n        for (uint i = 0; i < totalSupply; i++) {\n            for (uint j = 0; j < seeds[i].indices.length; j++) {\n                mintedIndicesArray[words++] = seeds[i].indices[j];\n            }\n        }\n        return mintedIndicesArray;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 BINDING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * This method allows a seed poem to be bound to a specific\n     * address that is derived from the seed itself.\n     * @param id tokenId of the poem to be bound\n     */\n    function bind(\n        uint256 id,\n        address to /*, message, signature, address */\n    ) public {\n        require(ownerOf(id) == msg.sender, \"ONLY_OWNER\");\n        // TODO: require valid signature signed offchain by the artist's \"validator\"\n        transferFrom(msg.sender, to, id);\n        seeds[id].bound = true;\n    }\n\n    // Inherit natspec\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(!seeds[id].bound, \"BOUND\");\n        super.transferFrom(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(!seeds[id].bound, \"BOUND\");\n        super.safeTransferFrom(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public override {\n        require(!seeds[id].bound, \"BOUND\");\n        super.safeTransferFrom(from, to, id, data);\n    }\n\n    /* /////////////////////////////////////////////////////////////\n                                 UTILS\n    //////////////////////////////////////////////////////////////*/\n\n    function withdraw(address payable _to) public onlyOwner {\n        (bool success, ) = _to.call{value: address(this).balance}(\"\");\n        require(success);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function renderSVG(uint256 _tokenId) external view returns (string memory) {\n        return\n            Render.renderSVG(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGFromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVG(indicesToWords(seedIndices), entropy, getFont());\n    }\n\n    function renderSVGBase64(\n        uint256 _tokenId\n    ) external view returns (string memory) {\n        return\n            Render.renderSVGBase64(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGBase64FromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVGBase64(\n                indicesToWords(seedIndices),\n                entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGstatic(\n        uint256 _tokenId\n    ) external view returns (string memory) {\n        return\n            Render.renderSVGstatic(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGstaticFromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVGstatic(\n                indicesToWords(seedIndices),\n                entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGBase64static(\n        uint256 _tokenId\n    ) external view returns (string memory) {\n        return\n            Render.renderSVGBase64static(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGBase64staticFromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVGBase64static(\n                indicesToWords(seedIndices),\n                entropy,\n                getFont()\n            );\n    }\n\n    function tokenURI(\n        uint256 _tokenId\n    ) public view override returns (string memory) {\n        require(_ownerOf[_tokenId] != address(0), \"NOT_MINTED\");\n        return\n            Render.tokenURI(\n                _tokenId,\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Font\n    ///////////////////////////////////////////////////////////////////////////\n\n    function setFont(string calldata fontString) external onlyOwner {\n        font = SSTORE2.write(bytes(fontString));\n    }\n\n    function getFont() public view returns (string memory) {\n        return string(abi.encodePacked(SSTORE2.read(font)));\n    }\n}\n"
    },
    "src/libraries/Render.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Metadata} from \"./Metadata.sol\";\nimport {Util} from \"./Util.sol\";\nimport {Traits} from \"./Traits.sol\";\nimport {Background} from \"./Background.sol\";\nimport {TextLine} from \"./TextLine.sol\";\nimport {Traits} from \"./Traits.sol\";\nimport {SVG} from \"./SVG.sol\";\nimport {Effect} from \"./Effect.sol\";\n\n/// @notice Adopted from Bibos (0xf528e3381372c43f5e8a55b3e6c252e32f1a26e4)\nlibrary Render {\n    string public constant description = \"Seed Poems\";\n\n    /*//////////////////////////////////////////////////////////////\n                                TOKENURI\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(\n        uint256 _tokenId,\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        string memory wordsStr = words[0];\n        for (uint i = 1; i < words.length; i++) {\n            wordsStr = string(abi.encodePacked(wordsStr, \" \", words[i]));\n        }\n        return\n            Metadata.encodeMetadata({\n                _tokenId: _tokenId,\n                _name: _name(_tokenId),\n                _description: wordsStr,\n                _attributes: Traits.attributes(words, entropy),\n                _backgroundColor: Traits.backgroundColor(words, entropy),\n                _svg: _svg(words, entropy, base64font, false),\n                _animation: _svg(words, entropy, base64font, true)\n            });\n    }\n\n    function renderSVG(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return _svg(words, entropy, base64font, true);\n    }\n\n    function renderSVGBase64(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return Metadata._encodeSVG(_svg(words, entropy, base64font, true));\n    }\n\n    function renderSVGstatic(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return _svg(words, entropy, base64font, false);\n    }\n\n    function renderSVGBase64static(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return Metadata._encodeSVG(_svg(words, entropy, base64font, false));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    function _svg(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font,\n        bool animate\n    ) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"svg\",\n                SVG.svgAttributes(),\n                string.concat(\n                    \"<defs><style>\",\n                    '@font-face {font-family: \"EBGI\";src: url(\"',\n                    base64font,\n                    '\");',\n                    // \"text {text-transform: uppercase;\"\n                    \"}</style>\",\n                    Effect.vhsFilter(\n                        words.length <= 3 ? 4 : words.length <= 6\n                            ? 3\n                            : words.length <= 9\n                            ? 2\n                            : 1,\n                        Traits.distortionType(entropy),\n                        keccak256(\n                            abi.encodePacked(Traits.textColor(words, entropy))\n                        ) == keccak256(abi.encodePacked(\"#000000\")),\n                        animate\n                    ),\n                    \"</defs>\"\n                ),\n                Background.render(Traits.backgroundColor(words, entropy)),\n                SVG.element(\n                    \"g\",\n                    string.concat(\n                        SVG.filterAttribute(\"vhs\"),\n                        // ' style=\"mix-blend-mode:exclusion\" ',\n                        \" \",\n                        'transform=\"rotate(',\n                        Traits.textRotation(words, entropy),\n                        ')\"'\n                    ),\n                    _renderText(\n                        words,\n                        entropy,\n                        Traits.textColor(words, entropy)\n                    )\n                )\n            );\n    }\n\n    function _renderText(\n        string[] memory words,\n        bytes memory entropy,\n        string memory textColor\n    ) public pure returns (string memory) {\n        uint256 wordCount = words.length;\n        uint8 charsPerLine = 20;\n        if (wordCount == 21) charsPerLine = 19;\n        else if (wordCount == 18) charsPerLine = 18;\n        else if (wordCount == 15) charsPerLine = 17;\n        else if (wordCount == 12) charsPerLine = 16;\n        else if (wordCount == 9) charsPerLine = 15;\n        else if (wordCount == 6) charsPerLine = 12;\n        else if (wordCount == 3) charsPerLine = 9;\n        else if (wordCount != 24) revert(\"Invalid words per line\");\n\n        string[] memory tempLines = new string[](wordCount); // worst-case scenario, one word per line\n        string memory line;\n        uint256 lineCount = 0;\n\n        for (uint256 i = 0; i < words.length; i++) {\n            if (\n                bytes(line).length != 0 &&\n                bytes(line).length + bytes(words[i]).length + 1 > charsPerLine\n            ) {\n                tempLines[lineCount] = line;\n                lineCount++;\n                line = words[i];\n            } else {\n                if (bytes(line).length != 0) {\n                    line = string(abi.encodePacked(line, \" \", words[i]));\n                } else {\n                    line = words[i];\n                }\n            }\n\n            if (i == words.length - 1) {\n                tempLines[lineCount] = line;\n            }\n        }\n\n        string memory fontSize = \"125\";\n        uint256 yDistance = 120;\n        if (wordCount == 6) {\n            fontSize = \"93\";\n            yDistance = 93;\n        } else if (wordCount == 9) {\n            fontSize = \"75\";\n            yDistance = 75;\n        } else if (wordCount == 12) {\n            fontSize = \"75\";\n            yDistance = 75;\n        } else if (wordCount == 15) {\n            fontSize = \"65\";\n            yDistance = 65;\n        } else if (wordCount == 18) {\n            fontSize = \"62\";\n            yDistance = 62;\n        } else if (wordCount == 21) {\n            fontSize = \"57\";\n            yDistance = 57;\n        } else if (wordCount == 24) {\n            fontSize = \"55\";\n            yDistance = 55;\n        }\n\n        uint256 rotationSeed = Traits._rarity(entropy, \"rotation\");\n        bool isPositive = rotationSeed % 2 == 0;\n        uint256 degrees = (rotationSeed / 10) % 6;\n        bytes memory svgTexts;\n        for (uint256 i = 0; i <= lineCount; i++) {\n            svgTexts = abi.encodePacked(\n                svgTexts,\n                TextLine.render(\n                    tempLines[i],\n                    (\n                        isPositive\n                            ? 90 + degrees * (words.length > 12 ? 1 : 2)\n                            : 90 - degrees * (words.length > 12 ? 1 : 2)\n                    ),\n                    (444 - (lineCount * yDistance) / 2) + (i * yDistance),\n                    fontSize,\n                    textColor\n                )\n            );\n        }\n\n        return SVG.element(\"g\", \"\", string(svgTexts));\n    }\n\n    function _name(uint256 _tokenId) internal pure returns (string memory) {\n        return\n            string.concat(\"Mnemonic Poem \", Util.uint256ToString(_tokenId, 3));\n    }\n}\n"
    },
    "solady/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\n             * 80          | DUP1            | codeSize codeSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\n             * 3D          | RETURNDATASIZE  | 0 codeSize              | [0..codeSize): code |\n             * F3          | RETURN          |                         | [0..codeSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                data,\n                or(\n                    0x61000080600a3d393df300,\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                    shl(0x40, dataSize)\n                )\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "src/libraries/Metadata.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Base64} from \"./Base64.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Metadata {\n    string constant JSON_BASE64_HEADER = \"data:application/json;base64,\";\n    string constant SVG_XML_BASE64_HEADER = \"data:image/svg+xml;base64,\";\n\n    function encodeMetadata(\n        uint256 _tokenId,\n        string memory _name,\n        string memory _description,\n        string memory _attributes,\n        string memory _backgroundColor,\n        string memory _svg,\n        string memory _animation\n    ) internal pure returns (string memory) {\n        string memory metadata = string.concat(\n            \"{\",\n            Util.keyValue(\"tokenId\", Util.uint256ToString(_tokenId)),\n            \",\",\n            Util.keyValue(\"name\", _name),\n            \",\",\n            Util.keyValue(\"description\", _description),\n            \",\",\n            Util.keyValueNoQuotes(\"attributes\", _attributes),\n            \",\",\n            Util.keyValue(\"backgroundColor\", _backgroundColor),\n            \",\",\n            Util.keyValue(\"image\", _encodeSVG(_svg)),\n            \",\",\n            Util.keyValue(\"animation_url\", _encodeSVG(_animation)),\n            \"}\"\n        );\n\n        return _encodeJSON(metadata);\n    }\n\n    /// @notice base64 encode json\n    /// @param _json, stringified json\n    /// @return string, bytes64 encoded json with prefix\n    function _encodeJSON(\n        string memory _json\n    ) internal pure returns (string memory) {\n        return string.concat(JSON_BASE64_HEADER, Base64.encode(_json));\n    }\n\n    /// @notice base64 encode svg\n    /// @param _svg, stringified json\n    /// @return string, bytes64 encoded svg with prefix\n    function _encodeSVG(\n        string memory _svg\n    ) internal pure returns (string memory) {\n        return string.concat(SVG_XML_BASE64_HEADER, Base64.encode(bytes(_svg)));\n    }\n}\n"
    },
    "src/libraries/Util.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nlibrary Util {\n    error NumberHasTooManyDigits();\n\n    /// @notice wraps a string in quotes and adds a space after\n    function quote(string memory value) internal pure returns (string memory) {\n        return string.concat('\"', value, '\" ');\n    }\n\n    function keyValue(\n        string memory _key,\n        string memory _value\n    ) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\":\"', _value, '\"');\n    }\n\n    function keyValueNoQuotes(\n        string memory _key,\n        string memory _value\n    ) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\":', _value);\n    }\n\n    /// @notice converts a tokenId to string and pads to _digits digits\n    /// @dev tokenId must be less than 10**_digits\n    /// @param _tokenId, uint256, the tokenId\n    /// @param _digits, uint8, the number of digits to pad to\n    /// @return result the resulting string\n    function uint256ToString(\n        uint256 _tokenId,\n        uint8 _digits\n    ) internal pure returns (string memory result) {\n        uint256 max = 10 ** _digits;\n        if (_tokenId >= max) revert NumberHasTooManyDigits();\n        // add leading zeroes\n        result = uint256ToString(_tokenId + max);\n        assembly {\n            // cut off one character\n            result := add(result, 1)\n            // store new length = _digits\n            mstore(result, _digits)\n        }\n    }\n\n    /// @notice converts a uint256 to ascii representation, without leading zeroes\n    /// @param _value, uint256, the value to convert\n    /// @return result the resulting string\n    function uint256ToString(\n        uint256 _value\n    ) internal pure returns (string memory result) {\n        if (_value == 0) return \"0\";\n\n        assembly {\n            // largest uint = 2^256-1 has 78 digits\n            // reserve 110 = 78 + 32 bytes of data in memory\n            // (first 32 are for string length)\n\n            // get 110 bytes of free memory\n            result := add(mload(0x40), 110)\n            mstore(0x40, result)\n\n            // keep track of digits\n            let digits := 0\n\n            for {\n\n            } gt(_value, 0) {\n\n            } {\n                // increment digits\n                digits := add(digits, 1)\n                // go back one byte\n                result := sub(result, 1)\n                // compute ascii char\n                let c := add(mod(_value, 10), 48)\n                // store byte\n                mstore8(result, c)\n                // advance to next digit\n                _value := div(_value, 10)\n            }\n            // go back 32 bytes\n            result := sub(result, 32)\n            // store the length\n            mstore(result, digits)\n        }\n    }\n\n    function bytes1ToString(\n        bytes1 _value\n    ) internal pure returns (string memory) {\n        return uint256ToString(uint8(_value));\n    }\n\n    function uint8ToString(uint8 _value) internal pure returns (string memory) {\n        return uint256ToString(_value);\n    }\n\n    /// @notice will revert in any characters are not in [0-9]\n    function stringToUint256(\n        string memory _value\n    ) internal pure returns (uint256 result) {\n        // 0-9 are 48-57\n\n        bytes memory value = bytes(_value);\n        if (value.length == 0) return 0;\n        uint256 multiplier = 10 ** (value.length - 1);\n        uint256 i;\n        while (multiplier != 0) {\n            result += uint256((uint8(value[i]) - 48)) * multiplier;\n            unchecked {\n                multiplier /= 10;\n                ++i;\n            }\n        }\n    }\n\n    function bytes1ToHex(bytes1 _value) internal pure returns (string memory) {\n        bytes memory result = new bytes(2);\n        uint8 x = uint8(_value);\n\n        result[0] = getHexChar(x >> 4);\n        result[1] = getHexChar(x % 16);\n\n        return string(result);\n    }\n\n    function bytes32ToBytes(bytes32 x) internal pure returns (bytes memory) {\n        bytes memory bytesString = new bytes(32);\n        for (uint i = 0; i < 32; i++) {\n            if (x[i] == 0) {\n                bytesString[i] = bytes1(0x20);\n            } else {\n                bytesString[i] = x[i];\n            }\n        }\n        return abi.encodePacked(bytesString);\n    }\n\n    function bytes32ToString(bytes32 x) internal pure returns (string memory) {\n        return string(bytes32ToBytes(x));\n    }\n\n    function getHexChar(uint8 _value) internal pure returns (bytes1) {\n        if (_value < 10) {\n            return bytes1(_value + 48);\n        }\n        _value -= 10;\n        return bytes1(_value + 97);\n    }\n\n    function stringToBytes1(\n        string memory _value\n    ) internal pure returns (bytes1 result) {\n        return bytes1(uint8(stringToUint256(_value)));\n    }\n\n    function getRGBString(\n        bytes memory _palette,\n        uint256 _pos\n    ) internal pure returns (string memory result) {\n        return\n            string.concat(\n                \"#\",\n                Util.bytes1ToHex(_palette[3 * _pos]),\n                Util.bytes1ToHex(_palette[3 * _pos + 1]),\n                Util.bytes1ToHex(_palette[3 * _pos + 2])\n            );\n    }\n\n    function getRGBString(\n        bytes3 _color\n    ) internal pure returns (string memory result) {\n        return\n            string.concat(\n                \"#\",\n                Util.bytes1ToHex(_color[0]),\n                Util.bytes1ToHex(_color[1]),\n                Util.bytes1ToHex(_color[2])\n            );\n    }\n}\n"
    },
    "src/libraries/Traits.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\n\nlibrary Traits {\n    function distortionTrait(\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        uint256 distortion = distortionType(entropy);\n        distortion == 1 ? \"Low\" : distortion == 2 ? \"Med\" : \"High\";\n    }\n\n    function distortionType(\n        bytes memory entropy\n    ) internal pure returns (uint256) {\n        return (_rarity(entropy, \"distortion\") % 3) + 1; // 1-3\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 Colors\n    //////////////////////////////////////////////////////////////*/\n\n    function colorTrait(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string[3] memory color = colorType(words, entropy);\n        return color[0];\n    }\n\n    function colorType(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string[3] memory) {\n        uint256 colorRarity = _rarity(entropy, \"color\") % 78;\n        // if (colorRarity < 72) return [\"Inverse\", \"#000000\", \"#FFFFFF\"];\n        return [\"Void\", \"#F9F9F9\", \"#000000\"];\n    }\n\n    // function colorType(\n    //     string[] memory words,\n    //     bytes memory entropy\n    // ) internal pure returns (string[3] memory) {\n    //     uint256 colorRarity = _rarity(entropy, \"color\") % 100;\n    //     if (colorRarity < 4) return [\"Inverse\", \"#FFFFFF\", \"#000000\"];\n    //     if (colorRarity < 8) return [\"Sky\", \"#CBF2FE\", \"#FFFFFF\"];\n    //     if (colorRarity < 12) return [\"Rose\", \"#F4D9EE\", \"#FFFFFF\"];\n    //     if (colorRarity < 16) return [\"Blue\", \"#0000A6\", \"#FFFFFF\"];\n    //     if (colorRarity < 20) return [\"Blue\", \"#112748\", \"#FFFFFF\"];\n    //     if (colorRarity < 24) return [\"Red\", \"#BC1818\", \"#FFFFFF\"];\n    //     if (colorRarity < 28) return [\"Sand\", \"#E1D8C9\", \"#FFFFFF\"];\n    //     if (colorRarity < 32) return [\"Gray\", \"#E0E0E0\", \"#FFFFFF\"];\n    //     if (colorRarity < 36) return [\"Feather\", \"#A4AFC0\", \"#FFFFFF\"];\n    //     if (colorRarity < 40) return [\"Charcoal\", \"#36414F\", \"#FFFFFF\"];\n    //     if (colorRarity < 44) return [\"Mint\", \"#D9EED3\", \"#FFFFFF\"];\n    //     if (colorRarity < 48) return [\"Purple\", \"#5A00CD\", \"#FFFFFF\"];\n    //     if (colorRarity < 52) return [\"Yellow\", \"#FAC300\", \"#FFFFFF\"];\n    //     if (colorRarity < 56) return [\"Red\", \"#BC1818\", \"#FFFFFF\"];\n    //     if (colorRarity < 60) return [\"Brown\", \"#402F2F\", \"#FFFFFF\"];\n    //     if (colorRarity < 64) return [\"Orange\", \"#FF9C54\", \"#FFFFFF\"];\n    //     if (colorRarity < 68) return [\"Green\", \"#172E20\", \"#FFFFFF\"];\n    //     return [\"Void\", \"#111111\", \"#FFFFFF\"];\n    // }\n\n    // function colorType(\n    //     string[] memory words,\n    //     bytes memory entropy\n    // ) internal pure returns (string[3] memory) {\n    //     uint256 colorRarity = _rarity(entropy, \"color\") % 100;\n    //     if (colorRarity < 2) return [\"Inverse\", \"#FFFFFF\", \"#000000\"];\n    //     if (colorRarity < 5) return [\"Sky\", \"#CBF2FE\", \"#FFFFFF\"];\n    //     if (colorRarity < 8) return [\"Rose\", \"#F4D9EE\", \"#FFFFFF\"];\n    //     if (colorRarity < 11) return [\"Blue\", \"#0000A6\", \"#FFFFFF\"];\n    //     if (colorRarity < 14) return [\"Red\", \"#BC1818\", \"#FFFFFF\"];\n    //     if (colorRarity < 17) return [\"Sand\", \"#E1D8C9\", \"#FFFFFF\"];\n    //     return [\"Void\", \"#111111\", \"#FFFFFF\"];\n    // }\n\n    // function colorType(\n    //     string[] memory words,\n    //     bytes memory entropy\n    // ) internal pure returns (string[3] memory) {\n    //     uint256 colorRarity = _rarity(entropy, \"color\") % 79;\n    //     if (colorRarity < 1) return [\"Inverse\", \"#FFFFFF\", \"#000000\"];\n    //     else if (colorRarity < 6) return [\"Sky\", \"#000000\", \"#CBF2FE\"];\n    //     else if (colorRarity < 11) return [\"Rose\", \"#000000\", \"#F4D9EE\"];\n    //     else if (colorRarity < 16) return [\"Blue\", \"#000000\", \"#0000A6\"];\n    //     else if (colorRarity < 21) return [\"Red\", \"#000000\", \"#BC1818\"];\n    //     else if (colorRarity < 26) return [\"Sand\", \"#000000\", \"#E1D8C9\"];\n    //     // else if (colorRarity < 13) return [\"Pink\", \"#F89EE4\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 16) return [\"Yellow\", \"#FFD600\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     // else if (colorRarity < 55) return [\"Brown\", \"#132540\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 60) return [\"Beige\", \"#E0E0E0\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 75) return [\"Green\", \"#172E20\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else return [\"Void\", \"#000000\", \"#FFFFFF\"];\n    // }\n\n    // function colorType(\n    //     string[] memory words,\n    //     bytes memory entropy\n    // ) internal pure returns (string[3] memory) {\n    //     uint256 colorRarity = _rarity(entropy, \"color\") % 79;\n    //     if (colorRarity < 1) return [\"White\", \"#FFFFFF\", \"#000000\"];\n    //     else if (colorRarity < 6) return [\"Sky\", \"#CBF2FE\", \"#FFFFFF\"];\n    //     else if (colorRarity < 11) return [\"Rose\", \"#F4D9EE\", \"#FFFFFF\"];\n    //     else if (colorRarity < 16) return [\"Blue\", \"#0000A6\", \"#FFFFFF\"];\n    //     else if (colorRarity < 21) return [\"Red\", \"#BC1818\", \"#FFFFFF\"];\n    //     else if (colorRarity < 26) return [\"Sand\", \"#E1D8C9\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 13) return [\"Pink\", \"#F89EE4\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 16) return [\"Yellow\", \"#FFD600\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     // else if (colorRarity < 55) return [\"Brown\", \"#132540\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 60) return [\"Beige\", \"#E0E0E0\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 75) return [\"Green\", \"#172E20\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else return [\"Void\", \"#000000\", \"#FFFFFF\"];\n    // }\n\n    // function colorType(\n    //     string[] memory words,\n    //     bytes memory entropy\n    // ) internal pure returns (string[3] memory) {\n    //     uint256 colorRarity = _rarity(entropy, \"color\") % 79;\n    //     if (colorRarity < 1) return [\"Orange\", \"#ffff\", \"#000\"];\n    //     else if (colorRarity < 5) return [\"Gray\", \"#D3CFBD\", \"#FFFFFF\"];\n    //     else if (colorRarity < 10) return [\"Blue\", \"#0007B7\", \"#FFFFFF\"];\n    //     else if (colorRarity < 15) return [\"Orange\", \"#FF9C54\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 10) return [\"Charcoal\", \"#36414F\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 13) return [\"Pink\", \"#F89EE4\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 16) return [\"Yellow\", \"#FFD600\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     // else if (colorRarity < 55) return [\"Brown\", \"#132540\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 60) return [\"Beige\", \"#E0E0E0\", \"#FFFFFF\"];\n    //     // else if (colorRarity < 75) return [\"Green\", \"#172E20\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else return [\"Void\", \"#000000\", \"#FFFFFF\"];\n    // }\n\n    // function colorType(\n    //     string[] memory words,\n    //     bytes memory entropy\n    // ) internal pure returns (string[3] memory) {\n    //     uint256 colorRarity = _rarity(entropy, \"color\") % 79;\n    //     if (colorRarity < 5) return [\"Blue\", \"#0007B7\", \"#FFFFFF\"];\n    //     else if (colorRarity < 10) return [\"Gray\", \"#E0E0E0\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else if (colorRarity < 15) return [\"Petrol\", \"#00FF19\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else if (colorRarity < 20) return [\"Charcoal\", \"#36414F\", \"#FFFFFF\"];\n    //     else if (colorRarity < 25) return [\"Mint\", \"#ECFFB8\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else if (colorRarity < 30) return [\"Marine\", \"#74FFE6\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else if (colorRarity < 35) return [\"Purple\", \"#5A00CD\", \"#FFFFFF\"];\n    //     else if (colorRarity < 40) return [\"Pink\", \"#F89EE4\", \"#FFFFFF\"];\n    //     else if (colorRarity < 45) return [\"Yellow\", \"#FFD600\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else if (colorRarity < 50) return [\"Red\", \"#E81C10\", \"#FFFFFF\"];\n    //     else if (colorRarity < 55) return [\"Brown\", \"#402F2F\", \"#FFFFFF\"];\n    //     else if (colorRarity < 60) return [\"Beige\", \"#D3CFBD\", \"#FFFFFF\"];\n    //     else if (colorRarity < 65) return [\"Sky\", \"#81E1FF\", \"#FFFFFF\"];\n    //     else if (colorRarity < 70) return [\"Orange\", \"#FF9C54\", \"#FFFFFF\"];\n    //     else if (colorRarity < 75) return [\"Green\", \"#254A2E\", \"#FFFFFF\"];\n    //     else if (colorRarity < 77) return [\"White\", \"#FFFFFF\", \"#FFFFFF\"];\n    //     //\"#000000\"];\n    //     else return [\"Void\", \"#000000\", \"#FFFFFF\"];\n    // }\n\n    function backgroundColor(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string[3] memory color = colorType(words, entropy);\n        return color[1];\n    }\n\n    function textColor(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string[3] memory color = colorType(words, entropy);\n        return color[2];\n    }\n\n    function textRotation(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        uint256 rotationSeed = _rarity(entropy, \"rotation\");\n        bool isPositive = rotationSeed % 2 == 0;\n        uint256 degrees = (rotationSeed / 10) % 6;\n        uint256 float = (rotationSeed / 100) % 1000;\n        return\n            string.concat(\n                isPositive ? \"\" : \"-\",\n                Util.uint256ToString(degrees),\n                \".\",\n                Util.uint256ToString(float)\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 TRAITS\n    //////////////////////////////////////////////////////////////*/\n\n    function attributes(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string memory result = \"[\";\n        result = string.concat(\n            result,\n            _attribute(\"Color\", colorTrait(words, entropy)),\n            _attribute(\"Words\", Util.uint256ToString(words.length))\n        );\n        return string.concat(result, \"]\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    function _attribute(\n        string memory _traitType,\n        string memory _value\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"{\",\n                Util.keyValue(\"trait_type\", _traitType),\n                \",\",\n                Util.keyValue(\"value\", _value),\n                \"}\"\n            );\n    }\n\n    function _rarity(\n        bytes memory _seed,\n        string memory _salt\n    ) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(_seed, _salt)));\n    }\n}\n"
    },
    "src/libraries/Background.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {SVG} from \"./SVG.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Background {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(\n        string memory backgroundColor\n    ) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"rect\",\n                SVG.rectAttributes({\n                    _width: \"100%\",\n                    _height: \"100%\",\n                    _fill: backgroundColor,\n                    _attributes: \"\"\n                })\n            );\n    }\n}\n"
    },
    "src/libraries/TextLine.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\nimport {SVG} from \"./SVG.sol\";\n\nlibrary TextLine {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(\n        string memory text,\n        uint256 xOffset,\n        uint256 yOffset,\n        string memory fontSize,\n        string memory textColor\n    ) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"text\",\n                SVG.textAttributes({\n                    _fontSize: fontSize,\n                    _fontFamily: \"EBGI, EB Garamond Italic, Garamond Italic, EB Garamond, Garamond, serif\",\n                    _coords: [\n                        Util.uint256ToString(xOffset),\n                        Util.uint256ToString(yOffset)\n                    ],\n                    _fill: textColor,\n                    _attributes: 'dy=\"0.4em\"' // offset text so yCoord aligns with top of text (magic number)\n                }),\n                text\n            );\n    }\n}\n"
    },
    "src/libraries/SVG.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\n\nlibrary SVG {\n    /*//////////////////////////////////////////////////////////////\n                                 ELEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    function element(\n        string memory _type,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return string.concat(\"<\", _type, \" \", _attributes, \"/>\");\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _children\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"<\",\n                _type,\n                \" \",\n                _attributes,\n                \">\",\n                _children,\n                \"</\",\n                _type,\n                \">\"\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2\n    ) internal pure returns (string memory) {\n        return element(_type, _attributes, string.concat(_child1, _child2));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(_child1, _child2, _child3)\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(_child1, _child2, _child3, _child4)\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(_child1, _child2, _child3, _child4, _child5)\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(\n                    _child1,\n                    _child2,\n                    _child3,\n                    _child4,\n                    _child5,\n                    _child6\n                )\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6,\n        string memory _child7\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(\n                    _child1,\n                    _child2,\n                    _child3,\n                    _child4,\n                    _child5,\n                    _child6,\n                    _child7\n                )\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6,\n        string memory _child7,\n        string memory _child8\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(\n                    _child1,\n                    _child2,\n                    _child3,\n                    _child4,\n                    _child5,\n                    _child6,\n                    _child7,\n                    _child8\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ATTRIBUTES\n    //////////////////////////////////////////////////////////////*/\n\n    function svgAttributes() internal pure returns (string memory) {\n        return\n            string.concat(\n                'xmlns=\"http://www.w3.org/2000/svg\" '\n                'xmlns:xlink=\"http://www.w3.org/1999/xlink\" '\n                'width=\"100%\" '\n                'height=\"100%\" '\n                'viewBox=\"0 0 616 889\" ',\n                'preserveAspectRatio=\"xMidYMid meet\" ',\n                'fill=\"none\" '\n            );\n    }\n\n    function textAttributes(\n        string[2] memory _coords,\n        string memory _fontSize,\n        string memory _fontFamily,\n        string memory _fill,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"x=\",\n                Util.quote(_coords[0]),\n                \"y=\",\n                Util.quote(_coords[1]),\n                \"font-size=\",\n                Util.quote(string.concat(_fontSize, \"px\")),\n                \"font-family=\",\n                Util.quote(_fontFamily),\n                \"fill=\",\n                Util.quote(_fill),\n                \" \",\n                _attributes,\n                \" \"\n            );\n    }\n\n    function rectAttributes(\n        string memory _width,\n        string memory _height,\n        string memory _fill,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"width=\",\n                Util.quote(_width),\n                \"height=\",\n                Util.quote(_height),\n                \"fill=\",\n                Util.quote(_fill),\n                \" \",\n                _attributes,\n                \" \"\n            );\n    }\n\n    function filterAttribute(\n        string memory _id\n    ) internal pure returns (string memory) {\n        return string.concat(\"filter=\", '\"', \"url(#\", _id, \")\", '\" ');\n    }\n}\n"
    },
    "src/libraries/Effect.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {SVG} from \"./SVG.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Effect {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function vhsFilter(\n        uint256 vhsLevel,\n        uint256 distortionLevel,\n        bool invert,\n        bool animate\n    ) internal pure returns (string memory) {\n        string memory colorMatrix = invert\n            ? \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.35 0\"\n            : \"0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.35 0\";\n        return\n            string.concat(\n                '<defs><filter id=\"vhs\" x=\"0\" y=\"0\" width=\"616\" height=\"889\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                (\n                    vhsLevel == 1 ? \"-6\" : vhsLevel == 2 ? \"-9\" : vhsLevel == 3\n                        ? \"-10\"\n                        : /*l4+*/ \"-12\"\n                ),\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"BackgroundImageFix\" result=\"textBlur_pass1\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                vhsLevel == 1 ? \"-3\" : vhsLevel == 2 ? \"-4.5\" : vhsLevel == 3\n                    ? \"-5\"\n                    : /*l4+*/ \"-6\",\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"textBlur_pass1\" result=\"textBlur_pass2\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                vhsLevel == 1 ? \"3\" : vhsLevel == 2 ? \"4.5\" : vhsLevel == 3\n                    ? \"5\"\n                    : /*l4+*/ \"6\",\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"textBlur_pass2\" result=\"textBlur_pass3\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                vhsLevel == 1 ? \"-6\" : vhsLevel == 2 ? \"-9\" : vhsLevel == 3\n                    ? \"-10\"\n                    : /*l4+*/ \"-12\",\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"textBlur_pass3\" result=\"textBlur_pass4\" /><feBlend mode=\"normal\" in=\"SourceGraphic\" in2=\"textBlur_pass4\" result=\"shape\" /><feGaussianBlur stdDeviation=\"',\n                vhsLevel == 1 ? \"3.5\" : vhsLevel == 2 ? \"4\" : vhsLevel == 3\n                    ? \"4.5\"\n                    : /*l4+*/ \"5\",\n                '\" result=\"textBlur_pass5\" />',\n                '<feTurbulence baseFrequency=\".015\" type=\"fractalNoise\" />',\n                '<feColorMatrix type=\"hueRotate\" values=\"0\">',\n                (\n                    animate\n                        ? '<animate attributeName=\"values\" from=\"0\" to=\"360\" dur=\"16s\" repeatCount=\"indefinite\" />'\n                        : \"\"\n                ),\n                \"</feColorMatrix>\",\n                '<feDisplacementMap in=\"textBlur_pass5\" xChannelSelector=\"R\" yChannelSelector=\"B\" scale=\"',\n                distortionLevel == 1 ? \"10\" : distortionLevel == 2\n                    ? \"20\"\n                    : \"22\",\n                '\">',\n                (\n                    animate\n                        ? (\n                            string.concat(\n                                '<animate attributeName=\"scale\" values=\"',\n                                distortionLevel == 1\n                                    ? \"10;20;15;25;15;20;10\"\n                                    : distortionLevel == 2\n                                    ? \"20;30;30;20\"\n                                    : \"22:38:28:38:22\",\n                                '\" dur=\"16s\" repeatCount=\"indefinite\" />'\n                            )\n                        )\n                        : \"\"\n                ),\n                \"</feDisplacementMap></filter></defs>\"\n            );\n    }\n}\n"
    },
    "src/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    function encode(string memory _data) internal pure returns (string memory) {\n        return encode(bytes(_data));\n    }\n\n    function encode(bytes memory _data) internal pure returns (string memory) {\n        if (_data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((_data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := _data\n            let endPtr := add(dataPtr, mload(_data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(_data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 2000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363839343135303932363536"
      }
    }
  }
}