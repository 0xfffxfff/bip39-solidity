{
  "language": "Solidity",
  "sources": {
    "src/BIP39.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\ncontract BIP39 {\n    string constant public language = \"english\";\n    string[2048] public wordlist;\n    bool public finalized;\n    address private deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    modifier onlyDeployer {\n        require(msg.sender == deployer, \"only deployer\");\n        _;\n    }\n\n    function commitWords(string[] memory _wordsChunk, uint256 _offset) external onlyDeployer {\n        require(!finalized, \"finalized\");\n        require(_offset + _wordsChunk.length - 1 < 2048, \"index too high\");\n        for (uint256 i = 0; i < _wordsChunk.length; i++) {\n            wordlist[_offset + i] = _wordsChunk[i];\n        }\n    }\n\n    function finalizeWords() external onlyDeployer {\n        finalized = true;\n    }\n\n    function getWordlist() external view returns (string[2048] memory) {\n        return wordlist;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                BIP39\n    //////////////////////////////////////////////////////////////*/\n\n    function entropyToMnemonic(bytes memory entropy) public pure returns (uint[] memory) {\n        bytes32 hashedEntropy = sha256(entropy);\n        string memory binaryEntropy = \"\";\n        for (uint i = 0; i < entropy.length; i++) {\n            binaryEntropy = string(abi.encodePacked(binaryEntropy, uintToBinaryString(uint8(entropy[i]), 8)));\n        }\n        string memory binaryChecksum = substring(uintToBinaryString(uint256(hashedEntropy), 256), 0, entropy.length * 8 / 4);\n        string memory binaryString = string(abi.encodePacked(binaryEntropy, binaryChecksum));\n\n        uint mnemonicLength = (entropy.length * 8 + entropy.length / 4 + 7) / 11;\n\n        uint[] memory mnemonicIndices = new uint[](mnemonicLength);\n        for (uint i = 0; i < mnemonicLength; i++) {\n            uint index = binaryToUint(substring(binaryString, i * 11, min((i+1) * 11, bytes(binaryString).length)));\n            mnemonicIndices[i] = index;\n        }\n        return mnemonicIndices;\n    }\n\n\n    function entropyToMnemonicString(bytes memory entropy) public view returns (string[] memory) {\n        return indicesToWords(entropyToMnemonic(entropy));\n    }\n\n    function mnemonicToEntropy(uint[] memory wordIndices) public pure returns (bytes memory) {\n        require(wordIndices.length >= 3 && wordIndices.length <= 24 && wordIndices.length % 3 == 0, \"Invalid word count\");\n\n        uint concatLenBits = wordIndices.length * 11;\n        bytes memory concatBits = new bytes(concatLenBits);\n\n        for (uint wordIndex = 0; wordIndex < wordIndices.length; wordIndex++) {\n            uint ndx = wordIndices[wordIndex];\n\n            for (uint i = 0; i < 11; i++) {\n                bool isOne = (ndx & (1 << (10 - i))) != 0;\n                concatBits[(wordIndex * 11) + i] = isOne ? bytes1(uint8(1)) : bytes1(uint8(0));\n            }\n        }\n\n        uint checksumLengthBits = concatLenBits / 33;\n        uint entropyLengthBits = concatLenBits - checksumLengthBits;\n\n        bytes memory entropy = new bytes(entropyLengthBits / 8);\n        for (uint i = 0; i < entropy.length; i++) {\n            for (uint j = 0; j < 8; j++) {\n                if (uint8(concatBits[(i * 8) + j]) == 1) {\n                    entropy[i] = bytes1(uint8(entropy[i]) | uint8(1 << (7 - j)));\n                }\n            }\n        }\n\n        bytes32 hashBytes = sha256(entropy);\n\n        for (uint i = 0; i < checksumLengthBits; i++) {\n            require(\n                uint8(concatBits[entropyLengthBits + i]) == uint8(uint8(hashBytes[i / 8]) >> (7 - i % 8) & 1),\n                \"Failed checksum\"\n            );\n        }\n\n        return entropy;\n    }\n\n    function generateMnemonic(uint256 words) public view returns (uint[] memory) {\n        require(words >= 3 && words <= 24 && words % 3 == 0, \"Invalid word count\");\n        bytes memory entropy = generateEntropy(words);\n        uint[] memory mnemonicIndices = entropyToMnemonic(entropy);\n        return mnemonicIndices;\n    }\n\n    function generateMnemonic(uint256 words, bytes memory entropy) public pure returns (uint[] memory) {\n        require(words >= 3 && words <= 24 && words % 3 == 0, \"Invalid word count\");\n        uint[] memory mnemonicIndices = entropyToMnemonic(entropy);\n        return mnemonicIndices;\n    }\n\n    function generateMnemonicString(uint256 words) public view returns (string[] memory) {\n        return indicesToWords(generateMnemonic(words));\n    }\n\n    function generateMnemonicString(uint256 words, bytes memory entropy) public view returns (string[] memory) {\n        return indicesToWords(generateMnemonic(words, entropy));\n    }\n\n    function indicesToWords(uint256[] memory indices) public view returns (string[] memory) {\n        string[] memory words = new string[](indices.length);\n        for (uint index; index < indices.length; index++) {\n            words[index] = wordlist[indices[index]];\n        }\n        return words;\n    }\n\n    function generateEntropy(uint256 words) public view returns (bytes memory) {\n        require(words >= 3 && words <= 24 && words % 3 == 0, \"Invalid word count\");\n\n        bytes32 totalEntropy = keccak256(abi.encodePacked(\n            tx.origin,\n            blockhash(block.number - 1),\n            block.timestamp,\n            gasleft()\n        ));\n\n        uint256 bits = words / 3 * 32;\n        uint256 bytesLength = bits / 8;\n\n        bytes memory entropy = new bytes(bytesLength);\n        for (uint i = 0; i < bytesLength; i++) {\n            entropy[i] = totalEntropy[i];\n        }\n        return entropy;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Utility\n    //////////////////////////////////////////////////////////////*/\n\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex - startIndex);\n        for (uint i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function uintToBinaryString(uint256 x, uint256 length) internal pure returns (string memory) {\n        bytes memory result = new bytes(length);\n        for (uint i = 0; i < length; i++) {\n            uint8 b = uint8(uint(x) >> (length - 1 - i));\n            result[i] = b % 2 == 0 ? bytes1(uint8(48)) : bytes1(uint8(49));  // 48 and 49 are '0' and '1' in ASCII\n        }\n        return string(result);\n    }\n\n    function binaryToUint(string memory binaryString) internal pure returns (uint) {\n        bytes memory binaryBytes = bytes(binaryString);\n        uint result = 0;\n        for (uint i = 0; i < binaryBytes.length; i++) {\n            if (binaryBytes[i] == '1') {\n                result += 2**(binaryBytes.length - i - 1);\n            }\n        }\n        return result;\n    }\n\n    function min(uint a, uint b) private pure returns (uint) {\n        return a < b ? a : b;\n    }\n}"
    },
    "src/SeedPoems.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"solady/src/utils/SSTORE2.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./BIP39.sol\";\nimport \"./SeedPoemsAdmin.sol\";\nimport {Render} from \"./libraries/Render.sol\";\n\n////////////////////////////////////////////////////////////////////////\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                               seek                                 //\n//                               poet                                 //\n//                               seed                                 //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                       0xfff.eth    //\n//                                                                    //\n////////////////////////////////////////////////////////////////////////\n\ncontract SeedPoems is BIP39, SeedPoemsAdmin, ReentrancyGuard {\n    struct Seed {\n        uint256[] indices;\n        bytes entropy;\n        bool bound;\n    }\n\n    mapping(uint256 => Seed) public seeds;\n    mapping(bytes32 => bool) public isEntropyMinted;\n\n    address private font;\n\n    constructor() SeedPoemsAdmin() {\n        uint256[] memory seedIndices = new uint256[](3);\n        seedIndices[0] = 1560; // seek\n        seedIndices[1] = 1337; // poet\n        seedIndices[2] = 1559; // seed\n        _mintPoem(seedIndices, msg.sender, false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 MINT\n    //////////////////////////////////////////////////////////////*/\n\n    function _mintPoem(\n        uint256[] memory seedIndices,\n        address to,\n        bool bound\n    ) internal {\n        uint id = ++totalSupply;\n\n        // Keep track of words minted\n        totalWords += seedIndices.length;\n        require(\n            totalWords <= MAX_WORD_SUPPLY,\n            \"MINTABLE_WORD_LIMIT_REACHED_2048\"\n        );\n\n        // This generates the entropy from the seed indices\n        // and simultaneously validates the seed.\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n\n        // hash entropy to check if it has been minted\n        bytes32 entropyHash = keccak256(entropy);\n        require(!isEntropyMinted[entropyHash], \"MNEMONIC_ALREADY_MINTED\");\n        isEntropyMinted[entropyHash] = true;\n\n        // Store the seed\n        seeds[id] = Seed({\n            indices: seedIndices,\n            entropy: entropy,\n            bound: bound\n        });\n\n        // Mint the token\n        _mint(to, id);\n    }\n\n    function mint(\n        uint256[] memory seedIndices\n    )\n        external\n        payable\n        nonReentrant\n        publicMintChecks(seedIndices.length)\n    {\n        _mintPoem(seedIndices, msg.sender, false);\n    }\n\n    function mintArtist(\n        uint256[] memory seedIndices,\n        address to,\n        bool bound\n    )\n        external\n        payable\n        onlyOwner\n        ownerMintChecks(seedIndices.length)\n        nonReentrant\n    {\n        _mintPoem(seedIndices, to, bound);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 BINDING\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * This method allows a seed poem to be bound to a specific\n     * address that is derived from the seed itself.\n     * @param id tokenId of the poem to be bound\n     */\n    function bind(\n        uint256 id,\n        address to /*, message, signature, address */\n    ) public {\n        require(ownerOf(id) == msg.sender, \"ONLY_OWNER\");\n        transferFrom(msg.sender, to, id);\n        seeds[id].bound = true;\n        // TODO: require valid signature signed offchain by the artist's \"validator\"\n        revert('IMPLEMENT_ME');\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(!seeds[id].bound, \"BOUND\");\n        super.transferFrom(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(!seeds[id].bound, \"BOUND\");\n        super.safeTransferFrom(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public override {\n        require(!seeds[id].bound, \"BOUND\");\n        super.safeTransferFrom(from, to, id, data);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VIEW\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Intended to be used offchain\n     */\n    function getMintedIndices() external view returns (uint256[] memory) {\n        uint256[] memory mintedIndicesArray = new uint256[](totalWords);\n        uint words = 0;\n        for (uint i = 0; i < totalSupply; i++) {\n            for (uint j = 0; j < seeds[i].indices.length; j++) {\n                mintedIndicesArray[words++] = seeds[i].indices[j];\n            }\n        }\n        return mintedIndicesArray;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(\n        uint256 _tokenId\n    ) public view override returns (string memory) {\n        require(_ownerOf[_tokenId] != address(0), \"NOT_MINTED\");\n        return\n            Render.tokenURI(\n                _tokenId,\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVG(uint256 _tokenId) external view returns (string memory) {\n        return\n            Render.renderSVG(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGFromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVG(indicesToWords(seedIndices), entropy, getFont());\n    }\n\n    function renderSVGBase64(\n        uint256 _tokenId\n    ) external view returns (string memory) {\n        return\n            Render.renderSVGBase64(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGBase64FromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVGBase64(\n                indicesToWords(seedIndices),\n                entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGstatic(\n        uint256 _tokenId\n    ) external view returns (string memory) {\n        return\n            Render.renderSVGstatic(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGstaticFromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVGstatic(\n                indicesToWords(seedIndices),\n                entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGBase64static(\n        uint256 _tokenId\n    ) external view returns (string memory) {\n        return\n            Render.renderSVGBase64static(\n                indicesToWords(seeds[_tokenId].indices),\n                seeds[_tokenId].entropy,\n                getFont()\n            );\n    }\n\n    function renderSVGBase64staticFromWords(\n        uint256[] memory seedIndices\n    ) external view returns (string memory) {\n        bytes memory entropy = mnemonicToEntropy(seedIndices);\n        return\n            Render.renderSVGBase64static(\n                indicesToWords(seedIndices),\n                entropy,\n                getFont()\n            );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Font\n    ///////////////////////////////////////////////////////////////////////////\n\n    function setFont(\n        string calldata fontString\n    )\n        external\n        onlyOwner\n    {\n        font = SSTORE2.write(bytes(fontString));\n    }\n\n    function getFont() public view returns (string memory) {\n        return string(abi.encodePacked(SSTORE2.read(font)));\n    }\n}\n"
    },
    "src/SeedPoemsAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"solmate/src/tokens/ERC721.sol\";\nimport \"solady/src/auth/Ownable.sol\";\n\nerror IncorrectPrice();\nerror MaxSupply();\nerror Paused();\nerror ReserveMintingDisabled();\nerror MaxClaimed();\nerror NoReserveForAddress();\nerror MaxReserveClaim();\nerror MaxPublicSupply();\nerror InvalidProof();\n\nabstract contract SeedPoemsAdmin is ERC721, Ownable {\n\n    uint256 public constant MAX_WORD_SUPPLY = 2048;\n    uint256 public constant ARTIST_ALLOTMENT = 408; // 20% of words\n    uint256 public constant WORD_SUPPLY = MAX_WORD_SUPPLY - ARTIST_ALLOTMENT;\n    uint256 public constant PRICE = 0.03 ether;\n\n    uint256 public totalSupply;\n\n    uint256 public totalWords;\n    uint256 public publicClaimed;\n    mapping (address => uint) reserve;\n\n    bytes32 public reserveRoot;\n\n    bool public mintReserveActive = true;\n    bool public mintingPaused = true;\n\n    constructor () ERC721(\"Seed Poems\", \"SEED\") {\n        _initializeOwner(msg.sender);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                  Mint\n    //////////////////////////////////////////////////////////////*/\n\n    modifier publicMintChecks(uint256 words) {\n        if (totalWords + words > MAX_WORD_SUPPLY) revert MaxSupply();\n        if (mintingPaused) revert Paused();\n        if (publicClaimed + words > WORD_SUPPLY) revert MaxPublicSupply();\n        if (msg.value != PRICE) revert IncorrectPrice();\n        publicClaimed += words;\n        _;\n    }\n\n    modifier ownerMintChecks(uint256 words) {\n        if (totalWords + words > MAX_WORD_SUPPLY) revert MaxSupply();\n        _;\n    }\n\n    /// @notice Pause/Unpause minting\n    function setPause(bool value) public onlyOwner {\n        mintingPaused = value;\n    }\n\n    /// @notice Withdraws balance to address\n    function withdraw(address payable _to) public onlyOwner {\n        (bool success,) = _to.call{value: address(this).balance}(\"\");\n        require(success);\n    }\n\n}\n"
    },
    "src/libraries/Render.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Metadata} from \"./Metadata.sol\";\nimport {Util} from \"./Util.sol\";\nimport {Traits} from \"./Traits.sol\";\nimport {Background} from \"./Background.sol\";\nimport {TextLine} from \"./TextLine.sol\";\nimport {Traits} from \"./Traits.sol\";\nimport {SVG} from \"./SVG.sol\";\nimport {Effect} from \"./Effect.sol\";\n\nlibrary Render {\n    string public constant description = \"Seed Poems\";\n\n    /*//////////////////////////////////////////////////////////////\n                                TOKENURI\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(\n        uint256 _tokenId,\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        string memory wordString = words[0];\n        for (uint i = 1; i < words.length; i++) {\n            wordString = string.concat(wordString, \" \", words[i]);\n        }\n        return\n            Metadata.encodeMetadata({\n                _tokenId: _tokenId,\n                _name: wordString,\n                _description: wordString,\n                _attributes: Traits.attributes(words, entropy),\n                _backgroundColor: Traits.backgroundColor(words, entropy),\n                _svg: _svg(words, entropy, base64font, false),\n                _animation: _svg(words, entropy, base64font, true)\n            });\n    }\n\n    function renderSVG(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return _svg(words, entropy, base64font, true);\n    }\n\n    function renderSVGBase64(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return Metadata._encodeSVG(_svg(words, entropy, base64font, true));\n    }\n\n    function renderSVGstatic(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return _svg(words, entropy, base64font, false);\n    }\n\n    function renderSVGBase64static(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font\n    ) external pure returns (string memory) {\n        return Metadata._encodeSVG(_svg(words, entropy, base64font, false));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    function _svg(\n        string[] memory words,\n        bytes memory entropy,\n        string memory base64font,\n        bool animate\n    ) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"svg\",\n                SVG.svgAttributes(),\n                string.concat(\n                    \"<defs><style>\",\n                    '@font-face {font-family: \"EBGI\";src: url(\"',\n                    base64font,\n                    '\");',\n                    // \"text {text-transform: uppercase;\"\n                    \"}</style>\",\n                    Effect.vhsFilter(\n                        words.length <= 3 ? 4 : words.length <= 6\n                            ? 3\n                            : words.length <= 9\n                            ? 2\n                            : 1,\n                        Traits.distortionType(entropy),\n                        keccak256(\n                            abi.encodePacked(Traits.textColor(words, entropy))\n                        ) == keccak256(abi.encodePacked(\"#000000\")),\n                        animate\n                    ),\n                    \"</defs>\"\n                ),\n                Background.render(Traits.backgroundColor(words, entropy)),\n                SVG.element(\n                    \"g\",\n                    string.concat(\n                        SVG.filterAttribute(\"vhs\"),\n                        ' transform-origin: 50% 50%; ',\n                        'transform=\"rotate(',\n                        Traits.textRotation(words, entropy),\n                        ')\"'\n                    ),\n                    _renderText(\n                        words,\n                        entropy,\n                        Traits.textColor(words, entropy)\n                    )\n                )\n            );\n    }\n\n    function _renderText(\n        string[] memory words,\n        bytes memory entropy,\n        string memory textColor\n    ) public pure returns (string memory) {\n        uint256 wordCount = words.length;\n        uint8 charsPerLine = 20;\n        if (wordCount == 21) charsPerLine = 19;\n        else if (wordCount == 18) charsPerLine = 18;\n        else if (wordCount == 15) charsPerLine = 17;\n        else if (wordCount == 12) charsPerLine = 16;\n        else if (wordCount == 9) charsPerLine = 15;\n        else if (wordCount == 6) charsPerLine = 12;\n        else if (wordCount == 3) charsPerLine = 9;\n        else if (wordCount != 24) revert(\"Invalid words per line\");\n\n        // the worst-case scenario is one word per line\n        string[] memory tempLines = new string[](wordCount);\n        string memory line;\n        uint256 lineCount = 0;\n\n        for (uint256 i = 0; i < words.length; i++) {\n            if (\n                bytes(line).length != 0 &&\n                bytes(line).length + bytes(words[i]).length + 1 > charsPerLine\n            ) {\n                tempLines[lineCount] = line;\n                lineCount++;\n                line = words[i];\n            } else {\n                if (bytes(line).length != 0) {\n                    line = string(abi.encodePacked(line, \" \", words[i]));\n                } else {\n                    line = words[i];\n                }\n            }\n\n            if (i == words.length - 1) {\n                tempLines[lineCount] = line;\n            }\n        }\n\n        string memory fontSize = \"125\";\n        uint256 yDistance = 120;\n        if (wordCount == 6) {\n            fontSize = \"93\";\n            yDistance = 93;\n        } else if (wordCount == 9) {\n            fontSize = \"75\";\n            yDistance = 75;\n        } else if (wordCount == 12) {\n            fontSize = \"75\";\n            yDistance = 75;\n        } else if (wordCount == 15) {\n            fontSize = \"65\";\n            yDistance = 65;\n        } else if (wordCount == 18) {\n            fontSize = \"62\";\n            yDistance = 62;\n        } else if (wordCount == 21) {\n            fontSize = \"57\";\n            yDistance = 57;\n        } else if (wordCount == 24) {\n            fontSize = \"55\";\n            yDistance = 55;\n        }\n\n        string memory svgTexts;\n        for (uint256 i = 0; i <= lineCount; i++) {\n            svgTexts = string.concat(\n                svgTexts,\n                TextLine.render(\n                    tempLines[i],\n                    90,\n                    (444 - (lineCount * yDistance) / 2) + (i * yDistance),\n                    fontSize,\n                    textColor\n                )\n            );\n        }\n\n        return SVG.element(\"g\", \"\", svgTexts);\n    }\n}\n"
    },
    "solady/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\n             * 80          | DUP1            | codeSize codeSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\n             * 3D          | RETURNDATASIZE  | 0 codeSize              | [0..codeSize): code |\n             * F3          | RETURN          |                         | [0..codeSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                data,\n                or(\n                    0x61000080600a3d393df300,\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                    shl(0x40, dataSize)\n                )\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "solady/src/auth/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover\n/// may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
    },
    "src/libraries/Metadata.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Base64} from \"./Base64.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Metadata {\n    string constant JSON_BASE64_HEADER = \"data:application/json;base64,\";\n    string constant SVG_XML_BASE64_HEADER = \"data:image/svg+xml;base64,\";\n\n    function encodeMetadata(\n        uint256 _tokenId,\n        string memory _name,\n        string memory _description,\n        string memory _attributes,\n        string memory _backgroundColor,\n        string memory _svg,\n        string memory _animation\n    ) internal pure returns (string memory) {\n        string memory metadata = string.concat(\n            \"{\",\n            Util.keyValue(\"tokenId\", Util.uint256ToString(_tokenId)),\n            \",\",\n            Util.keyValue(\"name\", _name),\n            \",\",\n            Util.keyValue(\"description\", _description),\n            \",\",\n            Util.keyValueNoQuotes(\"attributes\", _attributes),\n            \",\",\n            Util.keyValue(\"backgroundColor\", _backgroundColor),\n            \",\",\n            Util.keyValue(\"image\", _encodeSVG(_svg)),\n            \",\",\n            Util.keyValue(\"animation_url\", _encodeSVG(_animation)),\n            \"}\"\n        );\n\n        return _encodeJSON(metadata);\n    }\n\n    /// @notice base64 encode json\n    /// @param _json, stringified json\n    /// @return string, bytes64 encoded json with prefix\n    function _encodeJSON(\n        string memory _json\n    ) internal pure returns (string memory) {\n        return string.concat(JSON_BASE64_HEADER, Base64.encode(_json));\n    }\n\n    /// @notice base64 encode svg\n    /// @param _svg, stringified json\n    /// @return string, bytes64 encoded svg with prefix\n    function _encodeSVG(\n        string memory _svg\n    ) internal pure returns (string memory) {\n        return string.concat(SVG_XML_BASE64_HEADER, Base64.encode(bytes(_svg)));\n    }\n}\n"
    },
    "src/libraries/Util.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nlibrary Util {\n    error NumberHasTooManyDigits();\n\n    /// @notice wraps a string in quotes and adds a space after\n    function quote(string memory value) internal pure returns (string memory) {\n        return string.concat('\"', value, '\" ');\n    }\n\n    function keyValue(\n        string memory _key,\n        string memory _value\n    ) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\":\"', _value, '\"');\n    }\n\n    function keyValueNoQuotes(\n        string memory _key,\n        string memory _value\n    ) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\":', _value);\n    }\n\n    /// @notice converts a tokenId to string and pads to _digits digits\n    /// @dev tokenId must be less than 10**_digits\n    /// @param _tokenId, uint256, the tokenId\n    /// @param _digits, uint8, the number of digits to pad to\n    /// @return result the resulting string\n    function uint256ToString(\n        uint256 _tokenId,\n        uint8 _digits\n    ) internal pure returns (string memory result) {\n        uint256 max = 10 ** _digits;\n        if (_tokenId >= max) revert NumberHasTooManyDigits();\n        // add leading zeroes\n        result = uint256ToString(_tokenId + max);\n        assembly {\n            // cut off one character\n            result := add(result, 1)\n            // store new length = _digits\n            mstore(result, _digits)\n        }\n    }\n\n    /// @notice converts a uint256 to ascii representation, without leading zeroes\n    /// @param _value, uint256, the value to convert\n    /// @return result the resulting string\n    function uint256ToString(\n        uint256 _value\n    ) internal pure returns (string memory result) {\n        if (_value == 0) return \"0\";\n\n        assembly {\n            // largest uint = 2^256-1 has 78 digits\n            // reserve 110 = 78 + 32 bytes of data in memory\n            // (first 32 are for string length)\n\n            // get 110 bytes of free memory\n            result := add(mload(0x40), 110)\n            mstore(0x40, result)\n\n            // keep track of digits\n            let digits := 0\n\n            for {\n\n            } gt(_value, 0) {\n\n            } {\n                // increment digits\n                digits := add(digits, 1)\n                // go back one byte\n                result := sub(result, 1)\n                // compute ascii char\n                let c := add(mod(_value, 10), 48)\n                // store byte\n                mstore8(result, c)\n                // advance to next digit\n                _value := div(_value, 10)\n            }\n            // go back 32 bytes\n            result := sub(result, 32)\n            // store the length\n            mstore(result, digits)\n        }\n    }\n\n    function bytes1ToString(\n        bytes1 _value\n    ) internal pure returns (string memory) {\n        return uint256ToString(uint8(_value));\n    }\n\n    function uint8ToString(uint8 _value) internal pure returns (string memory) {\n        return uint256ToString(_value);\n    }\n\n    /// @notice will revert in any characters are not in [0-9]\n    function stringToUint256(\n        string memory _value\n    ) internal pure returns (uint256 result) {\n        // 0-9 are 48-57\n\n        bytes memory value = bytes(_value);\n        if (value.length == 0) return 0;\n        uint256 multiplier = 10 ** (value.length - 1);\n        uint256 i;\n        while (multiplier != 0) {\n            result += uint256((uint8(value[i]) - 48)) * multiplier;\n            unchecked {\n                multiplier /= 10;\n                ++i;\n            }\n        }\n    }\n\n    function bytes1ToHex(bytes1 _value) internal pure returns (string memory) {\n        bytes memory result = new bytes(2);\n        uint8 x = uint8(_value);\n\n        result[0] = getHexChar(x >> 4);\n        result[1] = getHexChar(x % 16);\n\n        return string(result);\n    }\n\n    function bytes32ToBytes(bytes32 x) internal pure returns (bytes memory) {\n        bytes memory bytesString = new bytes(32);\n        for (uint i = 0; i < 32; i++) {\n            if (x[i] == 0) {\n                bytesString[i] = bytes1(0x20);\n            } else {\n                bytesString[i] = x[i];\n            }\n        }\n        return abi.encodePacked(bytesString);\n    }\n\n    function bytes32ToString(bytes32 x) internal pure returns (string memory) {\n        return string(bytes32ToBytes(x));\n    }\n\n    function getHexChar(uint8 _value) internal pure returns (bytes1) {\n        if (_value < 10) {\n            return bytes1(_value + 48);\n        }\n        _value -= 10;\n        return bytes1(_value + 97);\n    }\n\n    function stringToBytes1(\n        string memory _value\n    ) internal pure returns (bytes1 result) {\n        return bytes1(uint8(stringToUint256(_value)));\n    }\n\n    function getRGBString(\n        bytes memory _palette,\n        uint256 _pos\n    ) internal pure returns (string memory result) {\n        return\n            string.concat(\n                \"#\",\n                Util.bytes1ToHex(_palette[3 * _pos]),\n                Util.bytes1ToHex(_palette[3 * _pos + 1]),\n                Util.bytes1ToHex(_palette[3 * _pos + 2])\n            );\n    }\n\n    function getRGBString(\n        bytes3 _color\n    ) internal pure returns (string memory result) {\n        return\n            string.concat(\n                \"#\",\n                Util.bytes1ToHex(_color[0]),\n                Util.bytes1ToHex(_color[1]),\n                Util.bytes1ToHex(_color[2])\n            );\n    }\n}\n"
    },
    "src/libraries/Traits.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\n\nlibrary Traits {\n\n    function distortionTrait(\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        uint256 distortion = distortionType(entropy);\n        return distortion == 1 ? \"Low\" : distortion == 2 ? \"Medium\" : \"High\";\n    }\n\n    function distortionType(\n        bytes memory entropy\n    ) internal pure returns (uint256) {\n        return (_rarity(entropy, \"distortion\") % 3) + 1; // 1-3\n    }\n\n    function colorTrait(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string[3] memory color = colorType(words, entropy);\n        return color[0];\n    }\n\n    function colorType(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string[3] memory) {\n        return [\"Void\", \"#F9F9F9\", \"#000000\"];\n    }\n\n    function backgroundColor(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string[3] memory color = colorType(words, entropy);\n        return color[1];\n    }\n\n    function textColor(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string[3] memory color = colorType(words, entropy);\n        return color[2];\n    }\n\n    function textRotation(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        uint256 rotationSeed = _rarity(entropy, \"rotation\");\n        bool isPositive = rotationSeed % 2 == 0;\n        uint256 degrees = (rotationSeed / 10) % 6;\n        uint256 float = (rotationSeed / 100) % 1000;\n        return\n            string.concat(\n                isPositive ? \"\" : \"-\",\n                Util.uint256ToString(degrees),\n                \".\",\n                Util.uint256ToString(float)\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 TRAITS\n    //////////////////////////////////////////////////////////////*/\n\n    function attributes(\n        string[] memory words,\n        bytes memory entropy\n    ) internal pure returns (string memory) {\n        string memory result = \"[\";\n        result = string.concat(\n            result,\n            _attribute(\"Words\", Util.uint256ToString(words.length))\n        );\n        return string.concat(result, \"]\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    function _attribute(\n        string memory _traitType,\n        string memory _value\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"{\",\n                Util.keyValue(\"trait_type\", _traitType),\n                \",\",\n                Util.keyValue(\"value\", _value),\n                \"}\"\n            );\n    }\n\n    function _rarity(\n        bytes memory _seed,\n        string memory _salt\n    ) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(_seed, _salt)));\n    }\n}\n"
    },
    "src/libraries/Background.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {SVG} from \"./SVG.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Background {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(\n        string memory backgroundColor\n    ) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"rect\",\n                SVG.rectAttributes({\n                    _width: \"100%\",\n                    _height: \"100%\",\n                    _fill: backgroundColor,\n                    _attributes: \"\"\n                })\n            );\n    }\n}\n"
    },
    "src/libraries/TextLine.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\nimport {SVG} from \"./SVG.sol\";\n\nlibrary TextLine {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(\n        string memory text,\n        uint256 xOffset,\n        uint256 yOffset,\n        string memory fontSize,\n        string memory textColor\n    ) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"text\",\n                SVG.textAttributes({\n                    _fontSize: fontSize,\n                    _fontFamily: \"EBGI, EB Garamond Italic, Garamond Italic, EB Garamond, Garamond, serif\",\n                    _coords: [\n                        Util.uint256ToString(xOffset),\n                        Util.uint256ToString(yOffset)\n                    ],\n                    _fill: textColor,\n                    _attributes: 'dy=\"0.4em\"' // offset text so yCoord aligns with top of text (magic number)\n                }),\n                text\n            );\n    }\n}\n"
    },
    "src/libraries/SVG.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\n\nlibrary SVG {\n    /*//////////////////////////////////////////////////////////////\n                                 ELEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    function element(\n        string memory _type,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return string.concat(\"<\", _type, \" \", _attributes, \"/>\");\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _children\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"<\",\n                _type,\n                \" \",\n                _attributes,\n                \">\",\n                _children,\n                \"</\",\n                _type,\n                \">\"\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2\n    ) internal pure returns (string memory) {\n        return element(_type, _attributes, string.concat(_child1, _child2));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(_child1, _child2, _child3)\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(_child1, _child2, _child3, _child4)\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(_child1, _child2, _child3, _child4, _child5)\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(\n                    _child1,\n                    _child2,\n                    _child3,\n                    _child4,\n                    _child5,\n                    _child6\n                )\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6,\n        string memory _child7\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(\n                    _child1,\n                    _child2,\n                    _child3,\n                    _child4,\n                    _child5,\n                    _child6,\n                    _child7\n                )\n            );\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6,\n        string memory _child7,\n        string memory _child8\n    ) internal pure returns (string memory) {\n        return\n            element(\n                _type,\n                _attributes,\n                string.concat(\n                    _child1,\n                    _child2,\n                    _child3,\n                    _child4,\n                    _child5,\n                    _child6,\n                    _child7,\n                    _child8\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ATTRIBUTES\n    //////////////////////////////////////////////////////////////*/\n\n    function svgAttributes() internal pure returns (string memory) {\n        return\n            string.concat(\n                'xmlns=\"http://www.w3.org/2000/svg\" '\n                'xmlns:xlink=\"http://www.w3.org/1999/xlink\" '\n                'width=\"100%\" '\n                'height=\"100%\" '\n                'viewBox=\"0 0 616 889\" ',\n                'preserveAspectRatio=\"xMidYMid meet\" ',\n                'fill=\"none\" '\n            );\n    }\n\n    function textAttributes(\n        string[2] memory _coords,\n        string memory _fontSize,\n        string memory _fontFamily,\n        string memory _fill,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"x=\",\n                Util.quote(_coords[0]),\n                \"y=\",\n                Util.quote(_coords[1]),\n                \"font-size=\",\n                Util.quote(string.concat(_fontSize, \"px\")),\n                \"font-family=\",\n                Util.quote(_fontFamily),\n                \"fill=\",\n                Util.quote(_fill),\n                \" \",\n                _attributes,\n                \" \"\n            );\n    }\n\n    function rectAttributes(\n        string memory _width,\n        string memory _height,\n        string memory _fill,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"width=\",\n                Util.quote(_width),\n                \"height=\",\n                Util.quote(_height),\n                \"fill=\",\n                Util.quote(_fill),\n                \" \",\n                _attributes,\n                \" \"\n            );\n    }\n\n    function filterAttribute(\n        string memory _id\n    ) internal pure returns (string memory) {\n        return string.concat(\"filter=\", '\"', \"url(#\", _id, \")\", '\" ');\n    }\n}\n"
    },
    "src/libraries/Effect.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {SVG} from \"./SVG.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Effect {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function vhsFilter(\n        uint256 vhsLevel,\n        uint256 distortionLevel,\n        bool invert,\n        bool animate\n    ) internal pure returns (string memory) {\n        string memory colorMatrix = invert\n            ? \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.35 0\"\n            : \"0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.35 0\";\n        return\n            string.concat(\n                '<defs><filter id=\"vhs\" x=\"0\" y=\"0\" width=\"616\" height=\"889\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                (\n                    vhsLevel == 1 ? \"-6\" : vhsLevel == 2 ? \"-9\" : vhsLevel == 3\n                        ? \"-10\"\n                        : /*l4+*/ \"-12\"\n                ),\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"BackgroundImageFix\" result=\"textBlur_pass1\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                vhsLevel == 1 ? \"-3\" : vhsLevel == 2 ? \"-4.5\" : vhsLevel == 3\n                    ? \"-5\"\n                    : /*l4+*/ \"-6\",\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"textBlur_pass1\" result=\"textBlur_pass2\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                vhsLevel == 1 ? \"3\" : vhsLevel == 2 ? \"4.5\" : vhsLevel == 3\n                    ? \"5\"\n                    : /*l4+*/ \"6\",\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"textBlur_pass2\" result=\"textBlur_pass3\" /><feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\" /><feOffset dx=\"',\n                vhsLevel == 1 ? \"-6\" : vhsLevel == 2 ? \"-9\" : vhsLevel == 3\n                    ? \"-10\"\n                    : /*l4+*/ \"-12\",\n                '\" /><feGaussianBlur stdDeviation=\"2\" /><feComposite in2=\"hardAlpha\" operator=\"out\" /><feColorMatrix type=\"matrix\" values=\"',\n                colorMatrix,\n                '\" /><feBlend mode=\"normal\" in2=\"textBlur_pass3\" result=\"textBlur_pass4\" /><feBlend mode=\"normal\" in=\"SourceGraphic\" in2=\"textBlur_pass4\" result=\"shape\" /><feGaussianBlur stdDeviation=\"',\n                vhsLevel == 1 ? \"3.5\" : vhsLevel == 2 ? \"4\" : vhsLevel == 3\n                    ? \"4.5\"\n                    : /*l4+*/ \"5\",\n                '\" result=\"textBlur_pass5\" />',\n                '<feTurbulence baseFrequency=\".015\" type=\"fractalNoise\" />',\n                '<feColorMatrix type=\"hueRotate\" values=\"0\">',\n                (\n                    animate\n                        ? '<animate attributeName=\"values\" from=\"0\" to=\"360\" dur=\"16s\" repeatCount=\"indefinite\" />'\n                        : \"\"\n                ),\n                \"</feColorMatrix>\",\n                '<feDisplacementMap in=\"textBlur_pass5\" xChannelSelector=\"R\" yChannelSelector=\"B\" scale=\"',\n                distortionLevel == 1 ? \"10\" : distortionLevel == 2\n                    ? \"20\"\n                    : \"22\",\n                '\">',\n                (\n                    animate\n                        ? (\n                            string.concat(\n                                '<animate attributeName=\"scale\" values=\"',\n                                distortionLevel == 1\n                                    ? \"10;20;15;25;15;20;10\"\n                                    : distortionLevel == 2\n                                    ? \"20;30;30;20\"\n                                    : \"22:38:28:38:22\",\n                                '\" dur=\"16s\" repeatCount=\"indefinite\" />'\n                            )\n                        )\n                        : \"\"\n                ),\n                \"</feDisplacementMap></filter></defs>\"\n            );\n    }\n}\n"
    },
    "src/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    function encode(string memory _data) internal pure returns (string memory) {\n        return encode(bytes(_data));\n    }\n\n    function encode(bytes memory _data) internal pure returns (string memory) {\n        if (_data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((_data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := _data\n            let endPtr := add(dataPtr, mload(_data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(_data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 2000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363933363838393932323733"
      }
    }
  }
}